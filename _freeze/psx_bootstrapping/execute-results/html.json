{
  "hash": "3949c4c53284a2f2d1d575c6e6f2226b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bootstrapped Logistic Regression and Machine Learning Models for Predicting Stock Market Movements in the Pakistan Stock Exchange (PSX)\"\ntitle-banner-block: true\nauthor: \"Prof. Dr. Zahid Asghar\"\nformat: html\nexecute:\n  freeze: auto\n  warnings: false\n  message: false\neditor_options: \n  chunk_output_type: console\n---\n\n## 1. Loading and Preparing the Data\n\nThe first step is to load the PSX data, clean it, and perform necessary transformations for feature engineering.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)  # For data manipulation and visualization\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'tidyverse' was built under R version 4.5.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'purrr' was built under R version 4.5.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(caret)      # For model evaluation and cross-validation\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: lattice\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'lattice' was built under R version 4.5.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'caret'\n\nThe following object is masked from 'package:purrr':\n\n    lift\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(rpart)      # For Decision Trees\nlibrary(Metrics)    # For additional evaluation metrics\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'Metrics' was built under R version 4.5.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'Metrics'\n\nThe following objects are masked from 'package:caret':\n\n    precision, recall\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(janitor)    # For cleaning column names\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'janitor'\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(MASS)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'MASS'\n\nThe following object is masked from 'package:dplyr':\n\n    select\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(class)    # For KNN\nlibrary(boot)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'boot' was built under R version 4.5.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'boot'\n\nThe following object is masked from 'package:lattice':\n\n    melanoma\n```\n\n\n:::\n:::\n\n\n\n\nWe have psx data in csv format. We will load the data and inspect its structure.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsx <- read_csv(\"data/psx.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 1827 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): Date, Vol., Change %\ndbl (4): Price, Open, High, Low\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Inspect the data structure (rows, columns, and types)\ndim(psx)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1827    7\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(psx)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 1,827\nColumns: 7\n$ Date       <chr> \"11/15/2024\", \"11/14/2024\", \"11/13/2024\", \"11/12/2024\", \"11…\n$ Price      <dbl> 17.42, 17.19, 16.78, 16.86, 17.02, 17.22, 17.14, 17.31, 16.…\n$ Open       <dbl> 17.40, 16.70, 16.95, 17.00, 17.46, 17.14, 17.24, 17.24, 17.…\n$ High       <dbl> 17.60, 17.60, 16.95, 17.20, 17.46, 17.49, 17.60, 17.50, 17.…\n$ Low        <dbl> 16.90, 16.55, 16.50, 16.70, 16.97, 17.01, 17.00, 16.60, 16.…\n$ Vol.       <chr> \"896.83K\", \"1.01M\", \"239.44K\", \"179.95K\", \"364.92K\", \"208.0…\n$ `Change %` <chr> \"1.34%\", \"2.44%\", \"-0.47%\", \"-0.94%\", \"-1.16%\", \"0.47%\", \"-…\n```\n\n\n:::\n:::\n\n\n\n### 1. **Bootstrap Logistic Regression**\nApply bootstrap resampling to estimate logistic regression coefficients and evaluate variability.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Data cleaning and feature engineering\n\n\n#| label: data-cleaning\n\n# Convert the `Date` column to a proper Date format\npsx <- psx %>% \n  mutate(date = as.Date(Date, format = \"%m/%d/%Y\")) |> dplyr::select(-Date)\n# Clean column names to make them consistent and readable\npsx <- psx %>% clean_names()\n\n# Convert `change_percent` to numeric and create a new column `direction` for the stock movement (Up/Down)\npsx <- psx %>% \n  mutate(\n    change_percent = as.numeric(str_remove(change_percent, \"%\")),\n    direction = if_else(change_percent > 0, \"Up\", \"Down\")\n  )\n\n# Arrange data by ascending date to maintain temporal order\npsx <- psx %>% arrange(date)\n\n# Create lag variables for `change_percent` (lags of 1 to 5 days)\npsx <- psx %>% \n  mutate(\n    lag1 = lag(change_percent, 1),\n    lag2 = lag(change_percent, 2),\n    lag3 = lag(change_percent, 3),\n    lag4 = lag(change_percent, 4),\n    lag5 = lag(change_percent, 5)\n  )\n\n# Convert `vol` (volume) to numeric, handling the M and K suffixes\npsx <- psx %>% mutate(vol = as.numeric(str_replace_all(vol, c(\"M\" = \"e6\", \"K\" = \"e3\"))))\n\n# Drop rows with missing values (NA)\npsx_clean <- psx %>% drop_na()\n\n# Convert `direction` to numeric for binary classification (1 for \"Up\", 0 for \"Down\")\npsx_clean <- psx_clean %>%\n  mutate(direction = if_else(direction == \"Up\", 1, 0))\n```\n:::\n\n\n\n#### Define a Bootstrap Function:\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_logistic <- function(data, indices) {\n  sampled_data <- data[indices, ]\n  model <- glm(direction ~ lag1 + lag2 + lag3 + lag4 + lag5 + vol, \n               data = sampled_data, family = binomial)\n  return(coef(model))\n}\n```\n:::\n\n\n#### Apply Bootstrapping:\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nlogistic_boot_result <- boot(data = psx_clean, statistic = boot_logistic, R = 1000)\nprint(logistic_boot_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = psx_clean, statistic = boot_logistic, R = 1000)\n\n\nBootstrap Statistics :\n         original        bias     std. error\nt1* -5.236745e-01 -2.097142e-03 6.719302e-02\nt2* -6.414172e-02  7.111280e-05 1.749324e-02\nt3* -1.149754e-02  1.149087e-04 1.588335e-02\nt4* -4.222881e-03  7.199437e-04 1.633129e-02\nt5* -2.171095e-02 -1.378824e-03 1.638450e-02\nt6* -4.423349e-02 -1.337178e-03 1.472036e-02\nt7*  4.183911e-07  4.427846e-09 5.749570e-08\n```\n\n\n:::\n:::\n\n\n#### Visualize and Extract Confidence Intervals:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(logistic_boot_result)\n```\n\n::: {.cell-output-display}\n![](psx_bootstrapping_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboot.ci(boot.out = logistic_boot_result, type = c(\"norm\", \"basic\", \"perc\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\nBased on 1000 bootstrap replicates\n\nCALL : \nboot.ci(boot.out = logistic_boot_result, type = c(\"norm\", \"basic\", \n    \"perc\"))\n\nIntervals : \nLevel      Normal              Basic              Percentile     \n95%   (-0.6533, -0.3899 )   (-0.6570, -0.3905 )   (-0.6568, -0.3903 )  \nCalculations and Intervals on Original Scale\n```\n\n\n:::\n:::\n\n\n---\n\n### 2. **Bootstrap for LDA**\n\n#### Define a Bootstrap Function:\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_lda <- function(data, indices) {\n  sampled_data <- data[indices, ]\n  lda_model <- lda(direction ~ lag1 + lag2 + lag3 + lag4 + lag5 + vol, \n                    data = sampled_data)\n  predictions <- predict(lda_model, newdata = data)$class\n  accuracy <- mean(predictions == data$direction)\n  return(accuracy)\n}\n```\n:::\n\n\n#### Apply Bootstrapping: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nlda_boot_result <- boot(data = psx_clean, statistic = boot_lda, R = 500)\nprint(lda_boot_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = psx_clean, statistic = boot_lda, R = 500)\n\n\nBootstrap Statistics :\n     original     bias    std. error\nt1* 0.6053787 0.00270472 0.004244633\n```\n\n\n:::\n:::\n\n\n---\n\n### 3. **Bootstrap for QDA**\n\n#### Define a Bootstrap Function:\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_qda <- function(data, indices) {\n  sampled_data <- data[indices, ]\n  qda_model <- qda(direction ~ lag1 + lag2 + lag3 + lag4 + lag5 + vol, \n                    data = sampled_data)\n  predictions <- predict(qda_model, newdata = data)$class\n  accuracy <- mean(predictions == data$direction)\n  return(accuracy)\n}\n```\n:::\n\n\n#### Apply Bootstrapping:\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nqda_boot_result <- boot(data = psx_clean, statistic = boot_qda, R = 500)\nprint(qda_boot_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = psx_clean, statistic = boot_qda, R = 500)\n\n\nBootstrap Statistics :\n     original       bias    std. error\nt1* 0.5944018 -0.003982437  0.01522457\n```\n\n\n:::\n:::\n\n\n---\n\n### 4. **Bootstrap for KNN**\n\n#### Define a Bootstrap Function:\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_knn <- function(data, indices) {\n  train_data <- data[indices, ]\n  test_data <- data[-indices, ]\n  knn_model <- knn(\n    train = train_data[, c(\"lag1\", \"lag2\", \"lag3\", \"lag4\", \"lag5\", \"vol\")],\n    test = test_data[, c(\"lag1\", \"lag2\", \"lag3\", \"lag4\", \"lag5\", \"vol\")],\n    cl = train_data$direction,\n    k = 5\n  )\n  accuracy <- mean(knn_model == test_data$direction)\n  return(accuracy)\n}\n```\n:::\n\n\n#### Apply Bootstrapping:\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nknn_boot_result <- boot(data = psx_clean, statistic = boot_knn, R = 500)\nprint(knn_boot_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = psx_clean, statistic = boot_knn, R = 500)\n\n\nBootstrap Statistics :\n    original  bias    std. error\nt1*      NaN     NaN  0.01808283\n```\n\n\n:::\n:::\n\n\n---\n\n### 5. **Bootstrap for Decision Trees**\n\n#### Define a Bootstrap Function:\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_dt <- function(data, indices) {\n  sampled_data <- data[indices, ]\n  tree_model <- rpart(direction ~ lag1 + lag2 + lag3 + lag4 + lag5 + vol, \n                      data = sampled_data, method = \"class\")\n  predictions <- predict(tree_model, newdata = data, type = \"class\")\n  accuracy <- mean(predictions == data$direction)\n  return(accuracy)\n}\n```\n:::\n\n\n#### Apply Bootstrapping:\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\ndt_boot_result <- boot(data = psx_clean, statistic = boot_dt, R = 500)\nprint(dt_boot_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot(data = psx_clean, statistic = boot_dt, R = 500)\n\n\nBootstrap Statistics :\n     original        bias    std. error\nt1* 0.6262349 -0.0005060373   0.0107856\n```\n\n\n:::\n:::\n\n\n---\n\n### Summarize Results:\nAggregate accuracy or coefficients across models to compare:\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\n  logistic = mean(logistic_boot_result$t),\n  lda = mean(lda_boot_result$t),\n  qda = mean(qda_boot_result$t),\n  knn = mean(knn_boot_result$t),\n  decision_tree = mean(dt_boot_result$t)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$logistic\n[1] -0.09619826\n\n$lda\n[1] 0.6080834\n\n$qda\n[1] 0.5904193\n\n$knn\n[1] 0.5456178\n\n$decision_tree\n[1] 0.6257289\n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "psx_bootstrapping_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}